// <auto-generated/>
// --------------------------------------------------------------------------
// <copyright file="ResourceManager.cs" company="Chuck Hill">
// Copyright (c) 2020 Chuck Hill.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public License
// as published by the Free Software Foundation; either version 2.1
// of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// The GNU Lesser General Public License can be viewed at
// http://www.opensource.org/licenses/lgpl-license.php. If
// you unfamiliar with this license or have questions about
// it, here is an http://www.gnu.org/licenses/gpl-faq.html.
//
// All code and executables are provided "as is" with no warranty
// either express or implied. The author accepts no liability for
// any damage or loss of business that this product may cause.
// </copyright>
// <author>Chuck Hill</author>
// --------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Resources;
using System.Text.RegularExpressions;

namespace CsvExcelExportImport.TestConsole.Resources
{
    /// <summary>
    /// Custom resource manager for retrieving ALL localized embedded resources from a single assembly.
    /// </summary>
    public class ResourceManager : System.Resources.ResourceManager
    {
        private static readonly object lockObj = new object();

        private readonly CultureInfo neutralResourcesCulture;
        private static readonly FieldInfo resourceSetsField = typeof(System.Resources.ResourceManager).GetField("_resourceSets", BindingFlags.Instance | BindingFlags.NonPublic);

        private Dictionary<string, string> resNames; //cache of itefTag names/resource names

        private Dictionary<string, ResourceSet> _resourceSets //mirror name as found in base class
        {
            get
            {
                //This value may change so we must retrieve it every time.
                var value = (Dictionary<string, ResourceSet>)resourceSetsField.GetValue(this);
                if (value == null)
                {
                    value = new Dictionary<string, ResourceSet>();
                    resourceSetsField.SetValue(this,value);
                }
                return value;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="System.Resources.ResourceManager"/> class.
        /// Constructs a Resource Manager for files beginning with
        /// baseName in the directory specified by resourceDir
        /// or in the current directory. This Assembly-ignorant constructor is
        /// mostly useful for testing your own ResourceSet implementation.
        /// </summary>
        /// <param name="t">A type within the assembly where the resources reside</param>
        public ResourceManager(Type t) : base(t)
        {
            base.IgnoreCase = true;
            this.neutralResourcesCulture = GetNeutralResourcesLanguage(base.MainAssembly);
        }

        /// <summary>
        /// Get the appropriate load-on-demand localized resource. If the culture-specific 
        /// resource does not exist, use the default InvariantCulture resource.
        /// </summary>
        /// <param name="culture">CultureInfo to retrieve resources for.</param>
        /// <param name="createIfNotExists">Not used. We only retrieve the resources that are explicitly available.</param>
        /// <param name="tryParents">Not used. We only retrieve the resources that are explicitly available. We dont hunt for language</param>
        /// <returns></returns>
        protected override ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents)
        {
            lock (lockObj)
            {
                ResourceSet rs = null;
                var resourceSets = _resourceSets; //pre-evaluate because this is a complex property;
                if (neutralResourcesCulture.Equals(culture)) culture = CultureInfo.InvariantCulture;
                resourceSets.TryGetValue(culture.Name, out rs);

                if (rs == null)
                {
                    Stream store = null;
                    string resourceFileName = GetResourceFileName(culture);

                    store = base.MainAssembly.GetManifestResourceStream(resourceFileName);

                    //If we found the appropriate resources in the local assembly
                    if (store != null)
                    {
                        rs = new ResourceSet(store);
                        resourceSets.Add(culture.Name, rs); //save for future reference.
                    }
                    //else  //This will never occur!
                    //{
                    //    rs = base.InternalGetResourceSet(culture, createIfNotExists, tryParents);
                    //}
                }

                return rs;
            }
        }

        /// <summary>
        /// Given a CultureInfo, retrieve the full embedded resource name in the 
        /// specified assembly. NO satellite assemblies. All localized strings are
        /// in the assembly specified by the constructor. This will find all 
        /// localized resources no matter what sub-folder they reside in 
        /// (aka '\Resources\Strings.en-GB.resx').
        /// </summary>
        /// <param name="culture">
        /// Culture to retrieve the full localized resource name. If localized 
        /// resource does not exist, return InvariantCulture resource name.
        /// </param>
        /// <remarks>
        /// Valid resource names may be of the form (case-insensitive):
        ///   [namespace].[folder].Strings.fr-CA.resources
        ///   [namespace].[folder].Strings.fr-CA..resources
        ///   [namespace].[folder].Strings.fr-CAT.xxx.resources
        ///   [namespace].[folder].Strings.fr.resources
        ///   [namespace].[folder].Strings.fr..resources
        ///   [namespace].[folder].Strings.fr.XXX.resources
        ///   [namespace].[folder].Strings.resources
        ///   [namespace].[folder].Strings..resources
        /// </remarks>
        /// <returns>Resource name</returns>
        protected override string GetResourceFileName(CultureInfo culture)
        {
            //Load-on-demand the list of all string resources in specified assembly.
            if (this.resNames == null)
            {
                //See pattern match testing: https://regex101.com/r/aK6sB5/1
                Regex re = new Regex(@"\." + base.BaseName + @"\.(?<LANG>[a-z]{2,3}|[a-z]{2,3}-[a-z]{2,4})?(?:\..*)?resources$", RegexOptions.IgnoreCase | RegexOptions.Compiled);
                this.resNames = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
                foreach (var n in base.MainAssembly.GetManifestResourceNames())
                {
                    var m = re.Match(n);
                    if (!m.Success) continue;
                    this.resNames[m.Groups["LANG"].Value] = n;
                }
            }

            string value = null;
            if (this.resNames.TryGetValue(culture.Name, out value)) return value;

            //fall-back to language without region;
            var lang = culture.TwoLetterISOLanguageName;
            if (this.resNames.TryGetValue(lang, out value))
            {
                this.resNames[culture.Name] = value; //save for future reference
                return value;
            }

            //Go the extra mile and return resource name that first matches the language irrespective of the region.
            var kv = this.resNames.FirstOrDefault(m => m.Key.StartsWith(lang, StringComparison.InvariantCultureIgnoreCase));
            if (kv.Key != null)
            {
                this.resNames[culture.Name] = kv.Value; //save for future reference
                return kv.Value;
            }

            //Still not found, so return the InvariantCulture resource name, Strings.resources aka Strings.resx.
            return this.resNames.TryGetValue(string.Empty, out value) ? value : string.Empty;
        }
    }
}